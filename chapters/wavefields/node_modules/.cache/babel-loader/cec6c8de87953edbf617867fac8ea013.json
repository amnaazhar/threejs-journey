{"ast":null,"code":"import { Scene, PerspectiveCamera, DirectionalLight, Mesh, MeshBasicMaterial, Vector3, PCFSoftShadowMap, Color, Group, BoxGeometry, CapsuleGeometry, SphereGeometry, CircleGeometry, ConeGeometry, Clock, WebGLRenderer, TextureLoader, BufferGeometry, BufferAttribute, CylinderGeometry, MeshPhongMaterial, DoubleSide, AmbientLight, PointLight, PlaneGeometry, Fog } from 'three';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\nimport GUI from 'lil-gui';\nimport { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';\nimport { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';\nimport { AfterimagePass } from 'three/examples/jsm/postprocessing/AfterimagePass.js';\n\nclass WebGLApp {\n  constructor(parent) {\n    this.resize = (width, height) => {\n      this.camera.aspect = width / height;\n      this.camera.updateProjectionMatrix();\n      this.renderer.setSize(width, height);\n      this.composer.setSize(width, height);\n    };\n\n    this.addLights = () => {\n      this.createAmbientLight();\n      this.createPointLight();\n    };\n\n    this.createAmbientLight = () => {\n      this.ambientLight = new AmbientLight(0x999999, 1);\n      this.scene.add(this.ambientLight);\n    };\n\n    this.createPointLight = () => {\n      this.light = new PointLight(0xffffff, 0.3, 0);\n      this.light.castShadow = true;\n      this.light.shadow.mapSize.width = 5000;\n      this.light.shadow.mapSize.height = 5000;\n      this.light.position.set(0, 20, -5);\n      this.scene.add(this.light);\n      const light = new PointLight(0xffffff, 0.2, 0);\n      light.castShadow = false;\n      light.position.set(0, 30, 50);\n      this.scene.add(light);\n    };\n\n    this.animate = () => {\n      if (this.sphere != null) {\n        var x = Math.ceil(this.p.x / this.resolution);\n        var y = Math.ceil(this.p.y / this.resolution); // console.log(\"Value of boxes is:\", x, y)\n        // console.log(\"P.x: \", this.p.x,\"P.y: \", this.p.y)\n\n        var value = this.array_of_dir[x - 1][y - 1];\n        this.moveParticle(value);\n      }\n\n      this.composer.render(); //this.renderer.render( this.scene, this.camera )\n\n      requestAnimationFrame(this.animate);\n      this.controls.update();\n    };\n\n    this.moveParticle = value => {\n      this.p.vx += Math.cos(value) * -0.01;\n      this.p.vy += Math.sin(value) * 0.01; //this.p.x = x\n      //this.p.y = y\n\n      this.p.x += this.p.vx;\n      this.p.y += this.p.vy; // apply some friction so point doesn't speed up too much\n\n      this.p.vx *= 0.99;\n      this.p.vy *= 0.99; // wrap around edges of screen\n\n      if (this.p.x > this.width) this.p.x = 1;\n      if (this.p.y > this.height) this.p.y = 1;\n      if (this.p.x < 0) this.p.x = this.width;\n      if (this.p.y < 0) this.p.y = this.height;\n      this.sphere.position.set(this.p.x - this.width / 2, this.p.y - this.height / 2);\n    };\n\n    this.makeScene = () => {\n      //field setup\n      this.res = 25; // resolution\n\n      this.width = 450;\n      this.height = 450;\n      var value; // for field\n      //make an array of points with position and velocity\n\n      this.p = {\n        x: Math.random() * this.width,\n        y: Math.random() * this.height,\n        vx: 0,\n        vy: 0\n      };\n      this.sphere = new Mesh(new SphereGeometry(5, 5, 32), new MeshBasicMaterial({\n        color: 0x0000ff\n      }));\n      this.sphere.position.set(this.p.x, this.p.y);\n      this.scene.add(this.sphere); //making array to store field values\n\n      this.array_of_boxes = new Array(); // helper code to visualize field\n\n      this.array_of_dir = new Array(); // array with all the vectors of the field\n      // console.log(\"P is \", this.p)\n      // console.log(\"width height is\", this.width, this.height)\n      //with wireframed cones to visualize\n\n      for (var x = 0; x < this.width; x += res) {\n        //console.log(x/res)\n        this.array_of_dir[x / res] = new Array();\n        this.array_of_boxes[x / res] = new Array();\n\n        for (var y = 0; y < this.height; y += res) {\n          value = Math.PI / 6;\n          const geometry = new ConeGeometry(5, 25, 3);\n          const cone = new Mesh(geometry, new MeshBasicMaterial({\n            color: 0x000000,\n            wireframe: true\n          })); //var cube = new Mesh(new BoxGeometry(res, res, 1), new MeshBasicMaterial( {color: 0x00ff00, wireframe:true} ))\n\n          cone.position.set(x - this.width / 2 + res / 2, y - this, height / 2 + res / 2, 10);\n          cone.rotateZ(value);\n          this.scene.add(cone);\n          this.array_of_dir[x / res][y / res] = value;\n          this.array_of_boxes[x / res][y / res] = cone;\n        }\n      }\n    };\n\n    this.createGUI = () => {\n      const gui = new GUI();\n      gui.add(this.afterimagePass.uniforms['damp'], 'value', 0, 1).step(0.001).name('Afterimage Damp');\n    };\n\n    this.angle = -2; // clean up: whats this?\n    //the main function\n\n    this.params = {\n      color: 0xff0000,\n      backgroundColor: 0xe2f0f9\n    };\n    const aspect = window.innerWidth / window.innerHeight; // const clock = new Clock()\n    //set up scene\n\n    this.scene = new Scene(); //this.scene.background = new Color(this.params.backgroundColor);\n    //add fog for trail fade\n\n    this.scene.fog = new Fog(0x000000, 1, 1000); // fog end\n    //camera setup\n\n    this.camera = new PerspectiveCamera(75, aspect, 0.1, 1000);\n    this.camera.position.z = -300;\n    this.scene.add(this.camera); //renderer set up\n\n    this.renderer = new WebGLRenderer({\n      antialias: true\n    });\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n    this.renderer.shadowMap.enabled = true;\n    this.renderer.shadowMap.type = PCFSoftShadowMap;\n    parent.appendChild(this.renderer.domElement); // postprocessing\n\n    this.composer = new EffectComposer(this.renderer);\n    this.composer.addPass(new RenderPass(this.scene, this.camera));\n    this.afterimagePass = new AfterimagePass();\n    this.composer.addPass(this.afterimagePass); // controls set up\n\n    this.controls = new OrbitControls(this.camera, this.renderer.domElement); //for cursor interaction\n    // this.cursor = {\n    //         x: 0,\n    //         y: 0\n    // }\n    //call init function here\n\n    this.addLights();\n    this.makeScene();\n    this.animate();\n    this.createGUI();\n  }\n\n}\n\nexport default WebGLApp; // makeGUI = (gui, folderName, obj) => {\n//     //gui face\n//     const objGUI = gui.addFolder(folderName);\n//     objGUI\n//         .add(obj.position,'x')\n//         .min(-10)\n//         .max(10)\n//         .step(0.01)\n//     objGUI\n//         .add(obj.position,'y')\n//         .min(-10)\n//         .max(10)\n//         .step(0.01)\n//     objGUI\n//         .add(obj.position,'z')\n//         .min(-Math.PI)\n//         .max(Math.PI)\n//         .step(0.01)\n//     objGUI\n//         .add(obj.rotation,'x')\n//         .min(-Math.PI)\n//         .max(Math.PI)\n//         .step(0.01)\n//         .name('rotX')\n//     objGUI\n//         .add(obj.rotation,'y')\n//         .min(-Math.PI)\n//         .max(Math.PI)\n//         .step(0.01)\n//         .name('rotY')\n//     objGUI\n//         .add(obj.rotation,'z')\n//         .min(-Math.PI)\n//         .max(Math.PI)\n//         .step(0.01)\n//         .name('rotZ')\n//     objGUI\n//         .addColor(this.params, 'color')\n//         .onChange(()=>{\n//             obj.material.color.set(this.params.color)\n//         })\n//     objGUI.close()\n// }\n// for (x=0; x < width ; x +-3){\n//     for (y = 0 y <height ; y +=3){\n//         cube (3,3)\n//         cube.position (x,y)\n//     }\n// }\n// COLORING BOXES CODE INSIDE ANIMATE FUNCTION\n//apply boundaries here\n// var x = Math.ceil((this.sphere.position.x + this.width/2)/this.resolution) - 1\n// var y = Math.ceil((this.sphere.position.y + this.height/2)/this.resolution) - 1\n// // helper code -- TODO: replace it with reading box values and applying it to particle\n// for (var m=0; m<this.array_of_boxes.length; m++){\n//     for (var n=0; n<this.array_of_boxes.length; n++){\n//         var temp = this.array_of_boxes[m][n]\n//         //console.log(this.array_of_boxes)\n//         temp.material.color = new Color(0x000000)\n//         temp.material.needsUpdate = true\n//        // this.sphere.\n//     }\n// }\n// var temp = this.array_of_boxes[x][y]\n// //console.log(this.array_of_boxes)\n// temp.material.color = new Color(0xff0000)\n// temp.material.needsUpdate = true\n// end of  helper code \n//MOVING: just animating the sphere\n// this.angle+=0.5;\n// if(this.angle> 360){\n//     this.angle=0;\n// }\n// this.sphere.position.x = Math.cos (this.angle * (Math.PI / 180)) * 120\n// this.sphere.position.y = Math.sin (this.angle * (Math.PI / 180)) * 120\n//get value\n// calculate new acceleration factor based on value direction\n// and add that to point's velocity\n\n/*\nIn pseudocode, that's something like:\n// starting point x = 500 y = 100\nbegin_curve()\nfor (n in [0..num_steps]) {\ndraw_vertex(x, y)\nx_offset = x - left_x     y_offset = y - top_y\ncolumn_index = int(x_offset / resolution)     row_index = int(y_offset / resolution)\n// NOTE: normally you want to check the bounds here     grid_angle = grid[column_index][row_index]\nx_step = step_length * cos(grid_angle)     y_step = step_length * sin(grid_angle)\nx = x + x_step     y = y + y_step }\nend_curve()\n*/","map":{"version":3,"sources":["/Users/amnaazhar/Desktop/threejs-journey/chapters/chapter2-flowfields/src/webglapp.js"],"names":["Scene","PerspectiveCamera","DirectionalLight","Mesh","MeshBasicMaterial","Vector3","PCFSoftShadowMap","Color","Group","BoxGeometry","CapsuleGeometry","SphereGeometry","CircleGeometry","ConeGeometry","Clock","WebGLRenderer","TextureLoader","BufferGeometry","BufferAttribute","CylinderGeometry","MeshPhongMaterial","DoubleSide","AmbientLight","PointLight","PlaneGeometry","Fog","OrbitControls","GUI","EffectComposer","RenderPass","AfterimagePass","WebGLApp","constructor","parent","resize","width","height","camera","aspect","updateProjectionMatrix","renderer","setSize","composer","addLights","createAmbientLight","createPointLight","ambientLight","scene","add","light","castShadow","shadow","mapSize","position","set","animate","sphere","x","Math","ceil","p","resolution","y","value","array_of_dir","moveParticle","render","requestAnimationFrame","controls","update","vx","cos","vy","sin","makeScene","res","random","color","array_of_boxes","Array","PI","geometry","cone","wireframe","rotateZ","createGUI","gui","afterimagePass","uniforms","step","name","angle","params","backgroundColor","window","innerWidth","innerHeight","fog","z","antialias","shadowMap","enabled","type","appendChild","domElement","addPass"],"mappings":"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","sourcesContent":["import{\n    Scene,\n    PerspectiveCamera,\n    DirectionalLight,\n    Mesh,\n    MeshBasicMaterial,\n    Vector3,\n    PCFSoftShadowMap,\n    Color,\n    Group,\n    BoxGeometry,\n    CapsuleGeometry,\n    SphereGeometry,\n    CircleGeometry,\n    ConeGeometry,\n    Clock,\n    WebGLRenderer,\n    TextureLoader,\n    BufferGeometry,\n    BufferAttribute,\n    CylinderGeometry,\n    MeshPhongMaterial,\n    DoubleSide,\n    AmbientLight,\n    PointLight,\n    PlaneGeometry,\n    Fog\n} from 'three'\n\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'\nimport GUI from 'lil-gui'; \nimport { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';\nimport { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';\nimport { AfterimagePass } from 'three/examples/jsm/postprocessing/AfterimagePass.js';\n\nclass WebGLApp {\n\n    constructor(parent){\n        \n        this.angle = -2; // clean up: whats this?\n        //the main function\n        this.params = {\n            color: 0xff0000,\n            backgroundColor: 0xe2f0f9\n        }\n        const aspect = window.innerWidth / window.innerHeight\n       // const clock = new Clock()\n        \n       //set up scene\n        this.scene = new Scene()\n        //this.scene.background = new Color(this.params.backgroundColor);\n        \n        //add fog for trail fade\n        this.scene.fog = new Fog( 0x000000, 1, 1000 );\n        // fog end\n        \n        //camera setup\n        this.camera = new PerspectiveCamera(75, aspect, 0.1, 1000)\n        this.camera.position.z = -300\n        this.scene.add( this.camera )\n\n        //renderer set up\n        this.renderer = new WebGLRenderer({antialias:true})\n        this.renderer.setSize(window.innerWidth, window.innerHeight)\n        this.renderer.shadowMap.enabled = true;\n        this.renderer.shadowMap.type = PCFSoftShadowMap;\n        parent.appendChild(this.renderer.domElement)\n\n        // postprocessing\n        this.composer = new EffectComposer( this.renderer );\n        this.composer.addPass( new RenderPass( this.scene, this.camera));\n        this.afterimagePass = new AfterimagePass();\n        this.composer.addPass( this.afterimagePass );\n\n        // controls set up\n        this.controls = new OrbitControls( this.camera, this.renderer.domElement );\n       \n        //for cursor interaction\n        // this.cursor = {\n        //         x: 0,\n        //         y: 0\n        // }\n\n        //call init function here\n        this.addLights()\n        this.makeScene()\n        this.animate()\n        this.createGUI()\n\n    }\n\n    resize = (width, height) => {\n        this.camera.aspect = width / height\n        this.camera.updateProjectionMatrix()\n        this.renderer.setSize(width, height)\n        this.composer.setSize(width, height);\n        \n    }\n\n    addLights= () =>{\n        this.createAmbientLight();\n        this.createPointLight();\n    }\n\n    createAmbientLight = () => {\n        this.ambientLight = new AmbientLight(0x999999, 1);\n        this.scene.add(this.ambientLight);\n    };\n    \n    createPointLight = () => {\n        this.light = new PointLight(0xffffff, 0.3, 0);\n        this.light.castShadow = true;\n        this.light.shadow.mapSize.width = 5000;\n        this.light.shadow.mapSize.height = 5000;\n        this.light.position.set(0,20,-5);\n        this.scene.add(this.light);\n\n        const light = new PointLight(0xffffff, 0.2, 0);\n        light.castShadow = false;\n        light.position.set(0,30,50);\n        this.scene.add(light);\n    };\n\n\n    animate = () => {\n        \n        if (this.sphere != null){\n\n            var x = Math.ceil((this.p.x)/this.resolution)\n            var y = Math.ceil((this.p.y)/this.resolution)\n            // console.log(\"Value of boxes is:\", x, y)\n            // console.log(\"P.x: \", this.p.x,\"P.y: \", this.p.y)\n            var value = this.array_of_dir[x-1][y-1]\n            this.moveParticle(value)\n        }\n        this.composer.render();\n        //this.renderer.render( this.scene, this.camera )\n        requestAnimationFrame( this.animate )\n        this.controls.update();\n    }\n\n    moveParticle = (value) => {\n\n        this.p.vx += Math.cos(value) * -0.01\n        this.p.vy += Math.sin(value) * 0.01\n        //this.p.x = x\n        //this.p.y = y\n\n        this.p.x += this.p.vx;\n        this.p.y += this.p.vy;\n\n        // apply some friction so point doesn't speed up too much\n        this.p.vx *= 0.99;\n        this.p.vy *= 0.99;\n\n        // wrap around edges of screen\n        if(this.p.x > this.width) this.p.x = 1;\n        if(this.p.y > this.height) this.p.y = 1;\n        if(this.p.x < 0) this.p.x = this.width;\n        if(this.p.y < 0) this.p.y = this.height;\n\n        this.sphere.position.set(this.p.x - this.width/2, this.p.y - this.height/2)\n\n    }\n    \n\n    makeScene = () => {\n\n        //field setup\n        this.res = 25 // resolution\n        this.width = 450\n        this.height = 450\n        var value; // for field\n        \n        //make an array of points with position and velocity\n        this.p = {\n            x: Math.random() * this.width,\n            y: Math.random() * this.height,\n            vx: 0,\n            vy: 0\n        }\n        this.sphere  = new Mesh(new SphereGeometry(5, 5, 32), new MeshBasicMaterial( {color: 0x0000ff} ))\n        this.sphere.position.set(this.p.x, this.p.y)\n        this.scene.add(this.sphere);\n\n        //making array to store field values\n        this.array_of_boxes = new Array(); // helper code to visualize field\n        this.array_of_dir = new Array(); // array with all the vectors of the field\n\n        // console.log(\"P is \", this.p)\n        // console.log(\"width height is\", this.width, this.height)\n\n        //with wireframed cones to visualize\n        for(var x = 0; x < this.width; x+=res ){\n            //console.log(x/res)\n            this.array_of_dir[x/res] = new Array();\n            this.array_of_boxes[x/res] = new Array();\n\n            for(var y = 0; y < this.height; y+=res){\n                \n                value = Math.PI/6\n\n                const geometry = new ConeGeometry( 5, 25, 3 )\n                const cone = new Mesh( geometry, new MeshBasicMaterial( {color: 0x000000, wireframe:true} ))\n                \n                //var cube = new Mesh(new BoxGeometry(res, res, 1), new MeshBasicMaterial( {color: 0x00ff00, wireframe:true} ))\n                cone.position.set(x-this.width/2+res/2, y-this,height/2+res/2, 10)\n                cone.rotateZ(value)\n                this.scene.add( cone )\n\n                this.array_of_dir [x/res][y/res] = value\n                this.array_of_boxes[x/res][y/res] = cone\n\n            }\n        }\n    }\n    \n    \n    createGUI = () => {\n\n        const gui = new GUI();\n        gui\n            .add( this.afterimagePass.uniforms[ 'damp' ], 'value', 0, 1 )\n            .step( 0.001 )\n            .name('Afterimage Damp')\n\n    }\n}\n\nexport default WebGLApp;\n\n\n\n\n    // makeGUI = (gui, folderName, obj) => {\n    //     //gui face\n    //     const objGUI = gui.addFolder(folderName);\n    //     objGUI\n    //         .add(obj.position,'x')\n    //         .min(-10)\n    //         .max(10)\n    //         .step(0.01)\n    //     objGUI\n    //         .add(obj.position,'y')\n    //         .min(-10)\n    //         .max(10)\n    //         .step(0.01)\n    //     objGUI\n    //         .add(obj.position,'z')\n    //         .min(-Math.PI)\n    //         .max(Math.PI)\n    //         .step(0.01)\n    //     objGUI\n    //         .add(obj.rotation,'x')\n    //         .min(-Math.PI)\n    //         .max(Math.PI)\n    //         .step(0.01)\n    //         .name('rotX')\n    //     objGUI\n    //         .add(obj.rotation,'y')\n    //         .min(-Math.PI)\n    //         .max(Math.PI)\n    //         .step(0.01)\n    //         .name('rotY')\n    //     objGUI\n    //         .add(obj.rotation,'z')\n    //         .min(-Math.PI)\n    //         .max(Math.PI)\n    //         .step(0.01)\n    //         .name('rotZ')\n    //     objGUI\n    //         .addColor(this.params, 'color')\n    //         .onChange(()=>{\n    //             obj.material.color.set(this.params.color)\n    //         })\n    //     objGUI.close()\n    // }\n\n\n// for (x=0; x < width ; x +-3){\n\n//     for (y = 0 y <height ; y +=3){\n\n//         cube (3,3)\n//         cube.position (x,y)\n\n\n//     }\n// }\n\n\n\n// COLORING BOXES CODE INSIDE ANIMATE FUNCTION\n\n\n\n            //apply boundaries here\n\n            // var x = Math.ceil((this.sphere.position.x + this.width/2)/this.resolution) - 1\n            // var y = Math.ceil((this.sphere.position.y + this.height/2)/this.resolution) - 1\n            \n            // // helper code -- TODO: replace it with reading box values and applying it to particle\n            // for (var m=0; m<this.array_of_boxes.length; m++){\n            //     for (var n=0; n<this.array_of_boxes.length; n++){\n\n            //         var temp = this.array_of_boxes[m][n]\n            //         //console.log(this.array_of_boxes)\n            //         temp.material.color = new Color(0x000000)\n            //         temp.material.needsUpdate = true\n\n            //        // this.sphere.\n                \n            //     }\n            // }\n            // var temp = this.array_of_boxes[x][y]\n            // //console.log(this.array_of_boxes)\n            // temp.material.color = new Color(0xff0000)\n            // temp.material.needsUpdate = true\n\n            // end of  helper code \n\n\n\n            //MOVING: just animating the sphere\n            // this.angle+=0.5;\n            // if(this.angle> 360){\n            //     this.angle=0;\n            // }\n            // this.sphere.position.x = Math.cos (this.angle * (Math.PI / 180)) * 120\n            // this.sphere.position.y = Math.sin (this.angle * (Math.PI / 180)) * 120\n            \n            //get value\n            // calculate new acceleration factor based on value direction\n            // and add that to point's velocity\n\n\n\n                    /*\n        In pseudocode, that's something like:\n\n        // starting point x = 500 y = 100\n        begin_curve()\n        for (n in [0..num_steps]) {\n            draw_vertex(x, y)\n            x_offset = x - left_x     y_offset = y - top_y\n            column_index = int(x_offset / resolution)     row_index = int(y_offset / resolution)\n            // NOTE: normally you want to check the bounds here     grid_angle = grid[column_index][row_index]\n            x_step = step_length * cos(grid_angle)     y_step = step_length * sin(grid_angle)\n            x = x + x_step     y = y + y_step }\n        end_curve()\n        */"]},"metadata":{},"sourceType":"module"}