{"ast":null,"code":"import { Scene, PerspectiveCamera, DirectionalLight, Mesh, MeshBasicMaterial, Vector3, PCFSoftShadowMap, Color, Group, BoxGeometry, CapsuleGeometry, SphereGeometry, CircleGeometry, ConeGeometry, Clock, WebGLRenderer, TextureLoader, BufferGeometry, BufferAttribute, CylinderGeometry, MeshPhongMaterial, DoubleSide, AmbientLight, PointLight, PlaneGeometry } from 'three';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\nimport GUI from 'lil-gui';\n\nclass WebGLApp {\n  constructor(parent) {\n    this.resize = (width, height) => {\n      this.camera.aspect = width / height;\n      this.camera.updateProjectionMatrix();\n      this.renderer.setSize(width, height);\n    };\n\n    this.addLights = () => {\n      this.createAmbientLight();\n      this.createPointLight();\n    };\n\n    this.createAmbientLight = () => {\n      this.ambientLight = new AmbientLight(0x999999, 1);\n      this.scene.add(this.ambientLight);\n    };\n\n    this.createPointLight = () => {\n      this.light = new PointLight(0xffffff, 0.3, 0);\n      this.light.castShadow = true;\n      this.light.shadow.mapSize.width = 5000;\n      this.light.shadow.mapSize.height = 5000;\n      this.light.position.set(0, 20, -5);\n      this.scene.add(this.light);\n      const light = new PointLight(0xffffff, 0.2, 0);\n      light.castShadow = false;\n      light.position.set(0, 30, 50);\n      this.scene.add(light);\n    };\n\n    this.animate = () => {\n      if (this.sphere != null) {\n        //apply boundaries here\n        var x = Math.ceil((this.sphere.position.x + this.width / 2) / this.resolution) - 1;\n        var y = Math.ceil((this.sphere.position.y + this.height / 2) / this.resolution) - 1; // helper code -- TODO: replace it with reading box values and applying it to particle\n\n        for (var m = 0; m < this.array_of_boxes.length; m++) {\n          for (var n = 0; n < this.array_of_boxes.length; n++) {\n            var temp = this.array_of_boxes[m][n]; //console.log(this.array_of_boxes)\n\n            temp.material.color = new Color(0x000000);\n            temp.material.needsUpdate = true; // this.sphere.\n          }\n        }\n\n        var temp = this.array_of_boxes[x][y]; //console.log(this.array_of_boxes)\n\n        temp.material.color = new Color(0xff0000);\n        temp.material.needsUpdate = true; // end of  helper code \n        //MOVING: just animating the sphere\n        // this.angle+=0.5;\n        // if(this.angle> 360){\n        //     this.angle=0;\n        // }\n        // this.sphere.position.x = Math.cos (this.angle * (Math.PI / 180)) * 120\n        // this.sphere.position.y = Math.sin (this.angle * (Math.PI / 180)) * 120\n        //get value\n        // calculate new acceleration factor based on value direction\n        // and add that to point's velocity\n\n        x = Math.ceil((this.p.x + this.width / 2) / this.resolution) - 1;\n        y = Math.ceil((this.p.y + this.height / 2) / this.resolution) - 1;\n        console.log(\"Value is:\", this.array_of_dir[x][y]);\n        var value = this.array_of_dir[this.p.x][this.p.y];\n        this.p.vx += Math.cos(value) * 0.8;\n        this.p.vy += Math.sin(value) * 0.8;\n        this.p.x += this.p.vx;\n        this.p.y += this.p.vy;\n        this.sphere.position.set(this.p.x, this.p.y); // apply some friction so point doesn't speed up too much\n\n        this.p.vx *= 0.99;\n        this.p.vy *= 0.99; // wrap around edges of screen\n\n        if (this.p.x > this.width) this.p.x = 0;\n        if (this.p.y > this.height) this.p.y = 0;\n        if (this.p.x < 0) this.p.x = this.width;\n        if (this.p.y < 0) this.p.y = this.height;\n      }\n\n      this.renderer.render(this.scene, this.camera);\n      requestAnimationFrame(this.animate);\n      this.controls.update();\n    };\n\n    this.makeScene = () => {\n      this.addLights(); // const gui = new GUI;\n\n      /*\n      In pseudocode, that's something like:\n       // starting point x = 500 y = 100\n      begin_curve()\n      for (n in [0..num_steps]) {\n          draw_vertex(x, y)\n          x_offset = x - left_x     y_offset = y - top_y\n          column_index = int(x_offset / resolution)     row_index = int(y_offset / resolution)\n          // NOTE: normally you want to check the bounds here     grid_angle = grid[column_index][row_index]\n          x_step = step_length * cos(grid_angle)     y_step = step_length * sin(grid_angle)\n          x = x + x_step     y = y + y_step }\n      end_curve()\n      */\n\n      var res = 25;\n      this.resolution = res;\n      const width = 450;\n      const height = 450;\n      var value;\n      this.width = width;\n      this.height = height; //make a point with position and velocity\n\n      this.p = {\n        x: Math.random() * this.width,\n        y: Math.random() * this.height,\n        vx: 0,\n        vy: 0\n      };\n      this.array_of_boxes = new Array();\n      this.array_of_dir = new Array();\n      console.log(width, height);\n      this.sphere = new Mesh(new SphereGeometry(5, 5, 32), new MeshBasicMaterial({\n        color: 0x0000ff\n      })); // this.sphere.position.set(width/2, height/2, 10)\n\n      this.sphere.position.set(this.p.x, this.p.y);\n      this.scene.add(this.sphere); //with triangles\n\n      for (var x = 0; x < width; x += res) {\n        //console.log(x/res)\n        this.array_of_dir[x / res] = new Array();\n        this.array_of_boxes[x / res] = new Array();\n\n        for (var y = 0; y < height; y += res) {\n          value = Math.PI / 6;\n          const geometry = new ConeGeometry(5, 25, 3);\n          const cone = new Mesh(geometry, new MeshBasicMaterial({\n            color: 0x000000,\n            wireframe: true\n          })); //var cube = new Mesh(new BoxGeometry(res, res, 1), new MeshBasicMaterial( {color: 0x00ff00, wireframe:true} ))\n\n          cone.position.set(x - width / 2 + res / 2, y - height / 2 + res / 2, 10);\n          cone.rotateZ(value);\n          this.scene.add(cone);\n          this.array_of_dir[x / res][y / res] = value;\n          this.array_of_boxes[x / res][y / res] = cone;\n        }\n      } //with rectangles\n      // for(var x = 0; x < width; x+=res ){\n      //     //console.log(x/res)\n      //     this.array_of_boxes[x/res] = new Array();\n      //     for(var y = 0; y < height; y+=res){\n      //         value = (x + y) * 0.01 * Math.PI * 2;\n      //         var cube = new Mesh(new BoxGeometry(res, res, 1), new MeshBasicMaterial( {color: 0x00ff00, wireframe:true} ))\n      //         cube.position.set(x-width/2+res/2, y-height/2+res/2, 10);\n      //         this.scene.add( cube );\n      //         this.array_of_boxes[x/res][y/res] = cube\n      //     }\n      // }\n      // //scene\n      // gui\n      // .addColor(this.params, 'backgroundColor')\n      // .onChange(()=>{\n      //     this.scene.background.set(this.params.backgroundColor)\n      // })\n      // gui.close()\n      // this.scene.add(gui)\n\n    };\n\n    this.makeGUI = (gui, folderName, obj) => {\n      //gui face\n      const objGUI = gui.addFolder(folderName);\n      objGUI.add(obj.position, 'x').min(-10).max(10).step(0.01);\n      objGUI.add(obj.position, 'y').min(-10).max(10).step(0.01);\n      objGUI.add(obj.position, 'z').min(-Math.PI).max(Math.PI).step(0.01);\n      objGUI.add(obj.rotation, 'x').min(-Math.PI).max(Math.PI).step(0.01).name('rotX');\n      objGUI.add(obj.rotation, 'y').min(-Math.PI).max(Math.PI).step(0.01).name('rotY');\n      objGUI.add(obj.rotation, 'z').min(-Math.PI).max(Math.PI).step(0.01).name('rotZ');\n      objGUI.addColor(this.params, 'color').onChange(() => {\n        obj.material.color.set(this.params.color);\n      });\n      objGUI.close();\n    };\n\n    this.angle = -2; //the main function\n\n    this.params = {\n      color: 0xff0000,\n      backgroundColor: 0xe2f0f9\n    };\n    const aspect = window.innerWidth / window.innerHeight; // const clock = new Clock()\n    //set up scene\n\n    this.scene = new Scene();\n    this.scene.background = new Color(this.params.backgroundColor);\n    this.camera = new PerspectiveCamera(75, aspect, 0.1, 1000);\n    this.renderer = new WebGLRenderer({\n      antialias: true\n    });\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n    this.renderer.shadowMap.enabled = true;\n    this.renderer.shadowMap.type = PCFSoftShadowMap;\n    this.scene.add(this.camera);\n    this.camera.position.z = -300; // controls\n\n    this.controls = new OrbitControls(this.camera, this.renderer.domElement); // this.resize(window.innerWidth, window.innerHeight)\n\n    this.cursor = {\n      x: 0,\n      y: 0\n    };\n    parent.appendChild(this.renderer.domElement);\n    this.makeScene();\n    this.animate();\n  }\n\n}\n\nexport default WebGLApp; // for (x=0; x < width ; x +-3){\n//     for (y = 0 y <height ; y +=3){\n//         cube (3,3)\n//         cube.position (x,y)\n//     }\n// }","map":{"version":3,"sources":["/Users/amnaazhar/Desktop/threejs-journey/chapters/chapter2-flowfields/src/webglapp.js"],"names":["Scene","PerspectiveCamera","DirectionalLight","Mesh","MeshBasicMaterial","Vector3","PCFSoftShadowMap","Color","Group","BoxGeometry","CapsuleGeometry","SphereGeometry","CircleGeometry","ConeGeometry","Clock","WebGLRenderer","TextureLoader","BufferGeometry","BufferAttribute","CylinderGeometry","MeshPhongMaterial","DoubleSide","AmbientLight","PointLight","PlaneGeometry","OrbitControls","GUI","WebGLApp","constructor","parent","resize","width","height","camera","aspect","updateProjectionMatrix","renderer","setSize","addLights","createAmbientLight","createPointLight","ambientLight","scene","add","light","castShadow","shadow","mapSize","position","set","animate","sphere","x","Math","ceil","resolution","y","m","array_of_boxes","length","n","temp","material","color","needsUpdate","p","console","log","array_of_dir","value","vx","cos","vy","sin","render","requestAnimationFrame","controls","update","makeScene","res","random","Array","PI","geometry","cone","wireframe","rotateZ","makeGUI","gui","folderName","obj","objGUI","addFolder","min","max","step","rotation","name","addColor","params","onChange","close","angle","backgroundColor","window","innerWidth","innerHeight","background","antialias","shadowMap","enabled","type","z","domElement","cursor","appendChild"],"mappings":"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","sourcesContent":["import{\n    Scene,\n    PerspectiveCamera,\n    DirectionalLight,\n    Mesh,\n    MeshBasicMaterial,\n    Vector3,\n    PCFSoftShadowMap,\n    Color,\n    Group,\n    BoxGeometry,\n    CapsuleGeometry,\n    SphereGeometry,\n    CircleGeometry,\n    ConeGeometry,\n    Clock,\n    WebGLRenderer,\n    TextureLoader,\n    BufferGeometry,\n    BufferAttribute,\n    CylinderGeometry,\n    MeshPhongMaterial,\n    DoubleSide,\n    AmbientLight,\n    PointLight,\n    PlaneGeometry\n} from 'three'\n\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'\nimport GUI from 'lil-gui'; \n\nclass WebGLApp {\n\n    constructor(parent){\n        \n        this.angle = -2;\n        //the main function\n        this.params = {\n            color: 0xff0000,\n            backgroundColor: 0xe2f0f9\n        }\n        const aspect = window.innerWidth / window.innerHeight\n       // const clock = new Clock()\n        //set up scene\n        this.scene = new Scene()\n        this.scene.background = new Color(this.params.backgroundColor);\n        this.camera = new PerspectiveCamera(75, aspect, 0.1, 1000)\n\n        this.renderer = new WebGLRenderer({antialias:true})\n        this.renderer.setSize(window.innerWidth, window.innerHeight)\n        this.renderer.shadowMap.enabled = true;\n        this.renderer.shadowMap.type = PCFSoftShadowMap;\n\n        this.scene.add( this.camera )\n        this.camera.position.z = -300\n\n        // controls\n        this.controls = new OrbitControls( this.camera, this.renderer.domElement );\n       // this.resize(window.innerWidth, window.innerHeight)\n       this.cursor = {\n            x: 0,\n            y: 0\n        }\n\n        parent.appendChild(this.renderer.domElement)\n        this.makeScene()\n        this.animate()\n\n    }\n\n    resize = (width, height) => {\n        this.camera.aspect = width / height\n        this.camera.updateProjectionMatrix()\n        this.renderer.setSize(width, height)\n        \n    }\n\n    addLights= () =>{\n        this.createAmbientLight();\n        this.createPointLight();\n    }\n\n    createAmbientLight = () => {\n        this.ambientLight = new AmbientLight(0x999999, 1);\n        this.scene.add(this.ambientLight);\n    };\n    \n    createPointLight = () => {\n        this.light = new PointLight(0xffffff, 0.3, 0);\n        this.light.castShadow = true;\n        this.light.shadow.mapSize.width = 5000;\n        this.light.shadow.mapSize.height = 5000;\n        this.light.position.set(0,20,-5);\n        this.scene.add(this.light);\n\n        const light = new PointLight(0xffffff, 0.2, 0);\n        light.castShadow = false;\n        light.position.set(0,30,50);\n        this.scene.add(light);\n    };\n\n\n    animate = () => {\n        \n        if (this.sphere != null){\n\n\n            //apply boundaries here\n\n            var x = Math.ceil((this.sphere.position.x + this.width/2)/this.resolution) - 1\n            var y = Math.ceil((this.sphere.position.y + this.height/2)/this.resolution) - 1\n            \n            // helper code -- TODO: replace it with reading box values and applying it to particle\n            for (var m=0; m<this.array_of_boxes.length; m++){\n                for (var n=0; n<this.array_of_boxes.length; n++){\n\n                    var temp = this.array_of_boxes[m][n]\n                    //console.log(this.array_of_boxes)\n                    temp.material.color = new Color(0x000000)\n                    temp.material.needsUpdate = true\n\n                   // this.sphere.\n                \n                }\n            }\n            var temp = this.array_of_boxes[x][y]\n            //console.log(this.array_of_boxes)\n            temp.material.color = new Color(0xff0000)\n            temp.material.needsUpdate = true\n\n            // end of  helper code \n\n\n\n            //MOVING: just animating the sphere\n            // this.angle+=0.5;\n            // if(this.angle> 360){\n            //     this.angle=0;\n            // }\n            // this.sphere.position.x = Math.cos (this.angle * (Math.PI / 180)) * 120\n            // this.sphere.position.y = Math.sin (this.angle * (Math.PI / 180)) * 120\n            \n            //get value\n            // calculate new acceleration factor based on value direction\n            // and add that to point's velocity\n            x = Math.ceil((this.p.x + this.width/2)/this.resolution) - 1\n            y = Math.ceil((this.p.y + this.height/2)/this.resolution) - 1\n            console.log(\"Value is:\", this.array_of_dir[x][y])\n            var value = this.array_of_dir[this.p.x][this.p.y]\n            this.p.vx += Math.cos(value) * 0.8\n            this.p.vy += Math.sin(value) * 0.8\n\n            this.p.x += this.p.vx;\n            this.p.y += this.p.vy;\n            this.sphere.position.set(this.p.x, this.p.y)\n\n            // apply some friction so point doesn't speed up too much\n            this.p.vx *= 0.99;\n            this.p.vy *= 0.99;\n\n            // wrap around edges of screen\n            if(this.p.x > this.width) this.p.x = 0;\n            if(this.p.y > this.height) this.p.y = 0;\n            if(this.p.x < 0) this.p.x = this.width;\n            if(this.p.y < 0) this.p.y = this.height;\n\n        }\n\n        this.renderer.render( this.scene, this.camera )\n        requestAnimationFrame( this.animate )\n        this.controls.update();\n    }\n\n    makeScene = () => {\n\n        this.addLights()\n        // const gui = new GUI;\n\n        /*\n        In pseudocode, that's something like:\n\n        // starting point x = 500 y = 100\n        begin_curve()\n        for (n in [0..num_steps]) {\n            draw_vertex(x, y)\n            x_offset = x - left_x     y_offset = y - top_y\n            column_index = int(x_offset / resolution)     row_index = int(y_offset / resolution)\n            // NOTE: normally you want to check the bounds here     grid_angle = grid[column_index][row_index]\n            x_step = step_length * cos(grid_angle)     y_step = step_length * sin(grid_angle)\n            x = x + x_step     y = y + y_step }\n        end_curve()\n        */\n            var res = 25\n            this.resolution = res\n            const width = 450\n            const height = 450\n            var value;\n            this.width = width\n            this.height = height\n            \n            //make a point with position and velocity\n            this.p = {\n                x: Math.random() * this.width,\n                y: Math.random() * this.height,\n                vx: 0,\n                vy: 0\n            }\n\n\n            this.array_of_boxes = new Array();\n            this.array_of_dir = new Array();\n            console.log(width, height)\n            this.sphere  = new Mesh(new SphereGeometry(5, 5, 32), new MeshBasicMaterial( {color: 0x0000ff} ))            \n           // this.sphere.position.set(width/2, height/2, 10)\n            this.sphere.position.set(this.p.x, this.p.y)\n            this.scene.add(this.sphere);\n            //with triangles\n\n            for(var x = 0; x < width; x+=res ){\n                //console.log(x/res)\n                this.array_of_dir[x/res] = new Array();\n                this.array_of_boxes[x/res] = new Array();\n                for(var y = 0; y < height; y+=res){\n                    \n                    value = Math.PI/6\n\n                    const geometry = new ConeGeometry( 5, 25, 3 )\n                    const cone = new Mesh( geometry, new MeshBasicMaterial( {color: 0x000000, wireframe:true} ))\n                   \n                    //var cube = new Mesh(new BoxGeometry(res, res, 1), new MeshBasicMaterial( {color: 0x00ff00, wireframe:true} ))\n                    cone.position.set(x-width/2+res/2, y-height/2+res/2, 10)\n                    cone.rotateZ(value)\n                    this.scene.add( cone )\n\n                    this.array_of_dir [x/res][y/res] = value\n                    this.array_of_boxes[x/res][y/res] = cone\n\n                }\n\n            }\n\n            //with rectangles\n            // for(var x = 0; x < width; x+=res ){\n            //     //console.log(x/res)\n            //     this.array_of_boxes[x/res] = new Array();\n            //     for(var y = 0; y < height; y+=res){\n                    \n            //         value = (x + y) * 0.01 * Math.PI * 2;\n                    \n            //         var cube = new Mesh(new BoxGeometry(res, res, 1), new MeshBasicMaterial( {color: 0x00ff00, wireframe:true} ))\n            //         cube.position.set(x-width/2+res/2, y-height/2+res/2, 10);\n            //         this.scene.add( cube );\n\n            //         this.array_of_boxes[x/res][y/res] = cube\n\n            //     }\n\n            // }\n\n        // //scene\n        // gui\n        // .addColor(this.params, 'backgroundColor')\n        // .onChange(()=>{\n        //     this.scene.background.set(this.params.backgroundColor)\n        // })\n\n        // gui.close()\n        // this.scene.add(gui)\n\n    }\n\n    makeGUI = (gui, folderName, obj) => {\n        //gui face\n        const objGUI = gui.addFolder(folderName);\n        objGUI\n            .add(obj.position,'x')\n            .min(-10)\n            .max(10)\n            .step(0.01)\n        objGUI\n            .add(obj.position,'y')\n            .min(-10)\n            .max(10)\n            .step(0.01)\n        objGUI\n            .add(obj.position,'z')\n            .min(-Math.PI)\n            .max(Math.PI)\n            .step(0.01)\n        objGUI\n            .add(obj.rotation,'x')\n            .min(-Math.PI)\n            .max(Math.PI)\n            .step(0.01)\n            .name('rotX')\n        objGUI\n            .add(obj.rotation,'y')\n            .min(-Math.PI)\n            .max(Math.PI)\n            .step(0.01)\n            .name('rotY')\n        objGUI\n            .add(obj.rotation,'z')\n            .min(-Math.PI)\n            .max(Math.PI)\n            .step(0.01)\n            .name('rotZ')\n        objGUI\n            .addColor(this.params, 'color')\n            .onChange(()=>{\n                obj.material.color.set(this.params.color)\n            })\n        objGUI.close()\n    }\n\n  \n\n}\n\nexport default WebGLApp;\n\n\n\n// for (x=0; x < width ; x +-3){\n\n//     for (y = 0 y <height ; y +=3){\n\n//         cube (3,3)\n//         cube.position (x,y)\n\n\n//     }\n// }"]},"metadata":{},"sourceType":"module"}