{"ast":null,"code":"import { MeshBasicMaterial, NearestFilter, ShaderMaterial, UniformsUtils, WebGLRenderTarget } from 'three';\nimport { Pass, FullScreenQuad } from './Pass.js';\nimport { AfterimageShader } from '../shaders/AfterimageShader.js';\n\nclass AfterimagePass extends Pass {\n  constructor() {\n    let damp = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0.96;\n    super();\n    if (AfterimageShader === undefined) console.error('THREE.AfterimagePass relies on AfterimageShader');\n    this.shader = AfterimageShader;\n    this.uniforms = UniformsUtils.clone(this.shader.uniforms);\n    this.uniforms['damp'].value = damp;\n    this.textureComp = new WebGLRenderTarget(window.innerWidth, window.innerHeight, {\n      magFilter: NearestFilter\n    });\n    this.textureOld = new WebGLRenderTarget(window.innerWidth, window.innerHeight, {\n      magFilter: NearestFilter\n    });\n    this.shaderMaterial = new ShaderMaterial({\n      uniforms: this.uniforms,\n      vertexShader: this.shader.vertexShader,\n      fragmentShader: this.shader.fragmentShader\n    });\n    this.compFsQuad = new FullScreenQuad(this.shaderMaterial);\n    const material = new MeshBasicMaterial();\n    this.copyFsQuad = new FullScreenQuad(material);\n  }\n\n  render(renderer, writeBuffer, readBuffer\n  /*, deltaTime, maskActive*/\n  ) {\n    this.uniforms['tOld'].value = this.textureOld.texture;\n    this.uniforms['tNew'].value = readBuffer.texture;\n    renderer.setRenderTarget(this.textureComp);\n    this.compFsQuad.render(renderer);\n    this.copyFsQuad.material.map = this.textureComp.texture;\n\n    if (this.renderToScreen) {\n      renderer.setRenderTarget(null);\n      this.copyFsQuad.render(renderer);\n    } else {\n      renderer.setRenderTarget(writeBuffer);\n      if (this.clear) renderer.clear();\n      this.copyFsQuad.render(renderer);\n    } // Swap buffers.\n\n\n    const temp = this.textureOld;\n    this.textureOld = this.textureComp;\n    this.textureComp = temp; // Now textureOld contains the latest image, ready for the next frame.\n  }\n\n  setSize(width, height) {\n    this.textureComp.setSize(width, height);\n    this.textureOld.setSize(width, height);\n  }\n\n}\n\nexport { AfterimagePass };","map":{"version":3,"sources":["/Users/amnaazhar/Desktop/threejs-journey/chapters/chapter2-flowfields/node_modules/three/examples/jsm/postprocessing/AfterimagePass.js"],"names":["MeshBasicMaterial","NearestFilter","ShaderMaterial","UniformsUtils","WebGLRenderTarget","Pass","FullScreenQuad","AfterimageShader","AfterimagePass","constructor","damp","undefined","console","error","shader","uniforms","clone","value","textureComp","window","innerWidth","innerHeight","magFilter","textureOld","shaderMaterial","vertexShader","fragmentShader","compFsQuad","material","copyFsQuad","render","renderer","writeBuffer","readBuffer","texture","setRenderTarget","map","renderToScreen","clear","temp","setSize","width","height"],"mappings":"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","sourcesContent":["import {\n\tMeshBasicMaterial,\n\tNearestFilter,\n\tShaderMaterial,\n\tUniformsUtils,\n\tWebGLRenderTarget\n} from 'three';\nimport { Pass, FullScreenQuad } from './Pass.js';\nimport { AfterimageShader } from '../shaders/AfterimageShader.js';\n\nclass AfterimagePass extends Pass {\n\n\tconstructor( damp = 0.96 ) {\n\n\t\tsuper();\n\n\t\tif ( AfterimageShader === undefined ) console.error( 'THREE.AfterimagePass relies on AfterimageShader' );\n\n\t\tthis.shader = AfterimageShader;\n\n\t\tthis.uniforms = UniformsUtils.clone( this.shader.uniforms );\n\n\t\tthis.uniforms[ 'damp' ].value = damp;\n\n\t\tthis.textureComp = new WebGLRenderTarget( window.innerWidth, window.innerHeight, {\n\t\t\tmagFilter: NearestFilter,\n\t\t} );\n\n\t\tthis.textureOld = new WebGLRenderTarget( window.innerWidth, window.innerHeight, {\n\t\t\tmagFilter: NearestFilter,\n\t\t} );\n\n\t\tthis.shaderMaterial = new ShaderMaterial( {\n\n\t\t\tuniforms: this.uniforms,\n\t\t\tvertexShader: this.shader.vertexShader,\n\t\t\tfragmentShader: this.shader.fragmentShader\n\n\t\t} );\n\n\t\tthis.compFsQuad = new FullScreenQuad( this.shaderMaterial );\n\n\t\tconst material = new MeshBasicMaterial();\n\t\tthis.copyFsQuad = new FullScreenQuad( material );\n\n\t}\n\n\trender( renderer, writeBuffer, readBuffer/*, deltaTime, maskActive*/ ) {\n\n\t\tthis.uniforms[ 'tOld' ].value = this.textureOld.texture;\n\t\tthis.uniforms[ 'tNew' ].value = readBuffer.texture;\n\n\t\trenderer.setRenderTarget( this.textureComp );\n\t\tthis.compFsQuad.render( renderer );\n\n\t\tthis.copyFsQuad.material.map = this.textureComp.texture;\n\n\t\tif ( this.renderToScreen ) {\n\n\t\t\trenderer.setRenderTarget( null );\n\t\t\tthis.copyFsQuad.render( renderer );\n\n\t\t} else {\n\n\t\t\trenderer.setRenderTarget( writeBuffer );\n\n\t\t\tif ( this.clear ) renderer.clear();\n\n\t\t\tthis.copyFsQuad.render( renderer );\n\n\t\t}\n\n\t\t// Swap buffers.\n\t\tconst temp = this.textureOld;\n\t\tthis.textureOld = this.textureComp;\n\t\tthis.textureComp = temp;\n\t\t// Now textureOld contains the latest image, ready for the next frame.\n\n\t}\n\n\tsetSize( width, height ) {\n\n\t\tthis.textureComp.setSize( width, height );\n\t\tthis.textureOld.setSize( width, height );\n\n\t}\n\n}\n\nexport { AfterimagePass };\n"]},"metadata":{},"sourceType":"module"}