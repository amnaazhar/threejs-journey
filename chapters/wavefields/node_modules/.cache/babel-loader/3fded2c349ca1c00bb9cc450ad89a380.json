{"ast":null,"code":"/* eslint-disable no-array-constructor */\nimport { Scene, PerspectiveCamera, Mesh, MeshBasicMaterial, PCFSoftShadowMap, Color, SphereGeometry, ConeGeometry, WebGLRenderer, AmbientLight, PointLight, Fog, Group, PlaneBufferGeometry, LineSegments, WireframeGeometry, LineBasicMaterial } from 'three';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\nimport GUI from 'lil-gui'; // import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';\n// import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';\n// import { AfterimagePass } from 'three/examples/jsm/postprocessing/AfterimagePass.js';\n\nimport { ImprovedNoise } from 'three/examples/jsm/math/ImprovedNoise.js';\nimport colors from './colors.js';\n\nclass WebGLApp {\n  constructor(parent) {\n    this.resize = (width, height) => {\n      this.camera.aspect = width / height;\n      this.camera.updateProjectionMatrix();\n      this.renderer.setSize(width, height);\n      this.composer.setSize(width, height);\n    };\n\n    this.addLights = () => {\n      this.createAmbientLight();\n      this.createPointLight();\n    };\n\n    this.createAmbientLight = () => {\n      this.ambientLight = new AmbientLight(0x999999, 1);\n      this.scene.add(this.ambientLight);\n    };\n\n    this.createPointLight = () => {\n      this.light = new PointLight(0xffffff, 0.3, 0);\n      this.light.castShadow = true;\n      this.light.shadow.mapSize.width = 5000;\n      this.light.shadow.mapSize.height = 5000;\n      this.light.position.set(0, 20, -5);\n      this.scene.add(this.light);\n      const light = new PointLight(0xffffff, 0.2, 0);\n      light.castShadow = false;\n      light.position.set(0, 30, 50);\n      this.scene.add(light);\n    };\n\n    this.animate = () => {\n      this.delta += 0.0025; // if (this.particleArr != null && this.array_of_dir != null && this.field_lines != null){\n      //     if(this.params.animatefield) this.animateField();\n      //     for(var i = 0; i < this.particleArr.length ; i++){\n      //         this.moveParticle(i)\n      //     }\n      // }\n\n      if (this.line) {\n        this.updateVertices(this.line);\n      }\n\n      this.renderer.render(this.scene, this.camera); //this.composer.render();\n\n      requestAnimationFrame(this.animate);\n      this.controls.update();\n    };\n\n    this.makeGeometry = () => {\n      var geometry = new PlaneBufferGeometry(this.width, this.height, 25, 25);\n      this.line = new LineSegments(new WireframeGeometry(geometry), new LineBasicMaterial({\n        color: 0xffffff\n      }));\n      this.line.rotation.x = Math.PI / 4;\n      this.scene.add(this.line);\n    };\n\n    this.moveParticle = i => {\n      var x = Math.ceil(this.particleArr[i].p.x / this.res) - 1;\n      var y = Math.ceil(this.particleArr[i].p.y / this.res) - 1;\n      var value = this.array_of_dir[x][y];\n      this.particleArr[i].p.vx += Math.cos(value) * -0.01;\n      this.particleArr[i].p.vy += Math.sin(value) * 0.01;\n      this.particleArr[i].p.x += this.particleArr[i].p.vx;\n      this.particleArr[i].p.y += this.particleArr[i].p.vy; // apply some friction so point doesn't speed up too much\n\n      this.particleArr[i].p.vx *= 0.99;\n      this.particleArr[i].p.vy *= 0.99; // wrap around edges of screen - boundaries\n\n      if (this.particleArr[i].p.x > this.width) this.particleArr[i].p.x = 1;\n      if (this.particleArr[i].p.y > this.height) this.particleArr[i].p.y = 1;\n      if (this.particleArr[i].p.x < 0) this.particleArr[i].p.x = this.width;\n      if (this.particleArr[i].p.y < 0) this.particleArr[i].p.y = this.height;\n      this.particleArr[i].sphere.position.set(this.particleArr[i].p.x - this.width / 2, this.particleArr[i].p.y - this.height / 2);\n    };\n\n    this.makeScene = () => {\n      //field setup\n      this.res = 25; // resolution\n\n      this.width = 450; // flowfield width and height\n\n      this.height = 450;\n      this.num_p = 25; // number of particles\n\n      this.makeGeometry(); //make an array of particles with position and velocity\n      //     this.particleArr = new Array()\n      //     for (var i = 0; i < this.num_p; i++){\n      //         var p = {\n      //             x: Math.random() * this.width,\n      //             y: Math.random() * this.height,\n      //             vx: 0,\n      //             vy: 0\n      //         }\n      //         var color = this.getRandomColor()\n      //         var sphere  = new Mesh(new SphereGeometry(5, 5, 32), new MeshBasicMaterial( {color: color} ))\n      //         sphere.position.set(p.x, p.y)\n      //         this.scene.add(sphere);\n      //         var particle = {\n      //             p:p, sphere:sphere\n      //         }\n      //         this.particleArr[i] = particle\n      //     }\n      //     //making array to store field values\n      //     this.array_of_boxes = new Array() // helper code to visualize field\n      //     this.array_of_dir = new Array() // array with all the vectors of the field\n      //     //with wireframed cones to visualize\n      //     //TO DO: data from perlin\n      //    // understanding the data\n      //    // get the debug working\n      //    // to the image\n      //     var value; // for field\n      //     for(var x = 0; x < this.width; x+=this.res ){\n      //         //console.log(x/res)\n      //         this.array_of_dir[x/this.res] = new Array();\n      //         this.array_of_boxes[x/this.res] = new Array();\n      //         for(var y = 0; y < this.height; y+=this.res){\n      //             value = this.perlin.noise( x * 0.65, y * 65, 0.65);\n      //             this.array_of_dir[x/this.res][y/this.res] = value * this.params.noise_value\n      //         }\n      //     }\n      //     this.makeField();\n    };\n\n    this.makeField = () => {\n      let angle = 0;\n      this.field_lines = new Group();\n\n      for (var x = 0; x < this.width; x += this.res) {\n        for (var y = 0; y < this.height; y += this.res) {\n          angle = this.array_of_dir[x / this.res][y / this.res]; //console.log(\"show field \", angle)\n\n          const geometry = new ConeGeometry(1, 25, 1);\n          const cone = new Mesh(geometry, new MeshBasicMaterial({\n            color: 0xffffff,\n            wireframe: true\n          })); //white color\n\n          cone.position.set(x - this.width / 2 + this.res / 2, y - this.height / 2 + this.res / 2, 10);\n          cone.rotateZ(angle);\n          this.field_lines.add(cone);\n        }\n      } //field lines needs to be rotated horizontally to go from ' | ' to ' __ '\n\n\n      this.field_lines.rotateZ(Math.PI / 2);\n      this.showField();\n    };\n\n    this.showField = () => {\n      if (this.params.showfield) this.scene.add(this.field_lines);else this.scene.remove(this.field_lines);\n    };\n\n    this.animateField = () => {\n      let value;\n      let num = 0;\n\n      for (var x = 0; x < this.width; x += this.res) {\n        for (var y = 0; y < this.height; y += this.res) {\n          value = this.perlin.noise(x * 0.65, y * 65, this.delta);\n          this.array_of_dir[x / this.res][y / this.res] = value * this.params.noise_value;\n          this.field_lines.children[num].rotateZ(value * this.params.noise_value);\n          num++;\n        }\n      }\n\n      this.delta += 0.00005;\n    };\n\n    this.createGUI = () => {\n      const gui = new GUI(); // gui\n      //     .add( this.afterimagePass.uniforms[ 'damp' ], 'value', 0, 1 )\n      //     .step( 0.001 )\n      //     .name('PostProcessing Damp')\n      // gui\n      //     .add(this.params, \"showfield\")\n      //     .onChange(this.showField)\n      //     .name('Show field')\n      // gui\n      //     .add(this.params, \"animatefield\")\n      //     .onChange(this.animateField)\n      //     .name('Animate field')\n      // gui\n      //     .add(this.params, \"noise_value\" , 'value', 0, 5)\n      //     .step( 0.1 )\n      //     .name('Noise value')\n    };\n\n    //the main function\n    // --- V A R S ----\n    this.params = {\n      color: 0xff0000,\n      backgroundColor: 0xe2f0f9,\n      showfield: true,\n      animatefield: false,\n      noise_value: 2\n    };\n    this.colorsArray = colors();\n    this.switch_field = false;\n    this.perlin = new ImprovedNoise();\n    this.delta = 0; //this.clock = new Clock();\n    // ---- BASIC SCENE SETUP----\n\n    const aspect = window.innerWidth / window.innerHeight; //scene\n\n    this.scene = new Scene(); //this.scene.background = new Color(this.params.backgroundColor);\n    //add fog for trail fade\n\n    this.scene.fog = new Fog(0x000000, 1, 1000); // fog end\n    //camera setup\n\n    this.camera = new PerspectiveCamera(75, aspect, 0.1, 1000);\n    this.camera.position.z = -300;\n    this.scene.add(this.camera); //renderer set up\n\n    this.renderer = new WebGLRenderer({\n      antialias: true\n    });\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n    this.renderer.shadowMap.enabled = true;\n    this.renderer.shadowMap.type = PCFSoftShadowMap;\n    parent.appendChild(this.renderer.domElement); // postprocessing\n    // this.composer = new EffectComposer( this.renderer );\n    // this.composer.addPass( new RenderPass( this.scene, this.camera));\n    // this.afterimagePass = new AfterimagePass();\n    // this.composer.addPass( this.afterimagePass );\n    // controls set up\n\n    this.controls = new OrbitControls(this.camera, this.renderer.domElement); //call init function here\n\n    this.addLights();\n    this.makeScene();\n    this.animate();\n    this.createGUI();\n  }\n\n  getRandomColor() {\n    //random color\n    var color = new Color();\n    color.setHex(`0x${this.colorsArray[Math.floor(Math.random() * this.colorsArray.length)]}`);\n\n    if (color < 500) {\n      color.setHex(500);\n    }\n\n    return color;\n  }\n\n  updateVertices(geom) {\n    var vertices = geom.geometry.attributes.position.array; //console.log(Math.random())\n\n    for (var i = 0; i <= vertices.length; i += 3) {\n      vertices[i + 2] = this.perlin.noise(vertices[i] / 800 + this.delta, vertices[i + 1] / 800 + this.delta, 0.65) * 300;\n    }\n\n    geom.geometry.attributes.position.needsUpdate = true;\n  }\n\n}\n\nexport default WebGLApp;","map":{"version":3,"sources":["/Users/amnaazhar/Desktop/threejs-journey/chapters/wavefields/src/webglapp.js"],"names":["Scene","PerspectiveCamera","Mesh","MeshBasicMaterial","PCFSoftShadowMap","Color","SphereGeometry","ConeGeometry","WebGLRenderer","AmbientLight","PointLight","Fog","Group","PlaneBufferGeometry","LineSegments","WireframeGeometry","LineBasicMaterial","OrbitControls","GUI","ImprovedNoise","colors","WebGLApp","constructor","parent","resize","width","height","camera","aspect","updateProjectionMatrix","renderer","setSize","composer","addLights","createAmbientLight","createPointLight","ambientLight","scene","add","light","castShadow","shadow","mapSize","position","set","animate","delta","line","updateVertices","render","requestAnimationFrame","controls","update","makeGeometry","geometry","color","rotation","x","Math","PI","moveParticle","i","ceil","particleArr","p","res","y","value","array_of_dir","vx","cos","vy","sin","sphere","makeScene","num_p","makeField","angle","field_lines","cone","wireframe","rotateZ","showField","params","showfield","remove","animateField","num","perlin","noise","noise_value","children","createGUI","gui","backgroundColor","animatefield","colorsArray","switch_field","window","innerWidth","innerHeight","fog","z","antialias","shadowMap","enabled","type","appendChild","domElement","getRandomColor","setHex","floor","random","length","geom","vertices","attributes","array","needsUpdate"],"mappings":"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","sourcesContent":["/* eslint-disable no-array-constructor */\nimport{\n    Scene,\n    PerspectiveCamera,\n    Mesh,\n    MeshBasicMaterial,\n    PCFSoftShadowMap,\n    Color,\n    SphereGeometry,\n    ConeGeometry,\n    WebGLRenderer,\n    AmbientLight,\n    PointLight,\n    Fog,\n    Group,\n    PlaneBufferGeometry,\n    LineSegments,\n    WireframeGeometry,\n    LineBasicMaterial,\n} from 'three'\n\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'\nimport GUI from 'lil-gui'; \n// import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';\n// import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';\n// import { AfterimagePass } from 'three/examples/jsm/postprocessing/AfterimagePass.js';\nimport { ImprovedNoise } from 'three/examples/jsm/math/ImprovedNoise.js';\nimport colors from './colors.js'\n\nclass WebGLApp {\n\n    constructor(parent){\n        \n        //the main function\n\n        // --- V A R S ----\n        this.params = {\n            color: 0xff0000,\n            backgroundColor: 0xe2f0f9,\n            showfield: true,\n            animatefield: false,\n            noise_value: 2\n        }\n        this.colorsArray = colors()\n        this.switch_field = false\n        this.perlin = new ImprovedNoise()\n        this.delta=0\n        //this.clock = new Clock();\n        // ---- BASIC SCENE SETUP----\n        const aspect = window.innerWidth / window.innerHeight\n       \n        //scene\n        this.scene = new Scene()\n        //this.scene.background = new Color(this.params.backgroundColor);\n        \n        //add fog for trail fade\n        this.scene.fog = new Fog( 0x000000, 1, 1000 );\n        // fog end\n        \n        //camera setup\n        this.camera = new PerspectiveCamera(75, aspect, 0.1, 1000)\n        this.camera.position.z = -300\n        this.scene.add( this.camera )\n\n        //renderer set up\n        this.renderer = new WebGLRenderer({antialias:true})\n        this.renderer.setSize(window.innerWidth, window.innerHeight)\n        this.renderer.shadowMap.enabled = true;\n        this.renderer.shadowMap.type = PCFSoftShadowMap;\n        parent.appendChild(this.renderer.domElement)\n\n        // postprocessing\n        // this.composer = new EffectComposer( this.renderer );\n        // this.composer.addPass( new RenderPass( this.scene, this.camera));\n        // this.afterimagePass = new AfterimagePass();\n        // this.composer.addPass( this.afterimagePass );\n\n        // controls set up\n        this.controls = new OrbitControls( this.camera, this.renderer.domElement );\n\n        //call init function here\n        this.addLights()\n        this.makeScene()\n        this.animate()\n        this.createGUI()\n\n    }\n\n    getRandomColor(){\n\n        //random color\n        var color = new Color();\n        color.setHex(`0x${this.colorsArray[Math.floor(Math.random() * this.colorsArray.length)]}`);\n        if (color < 500) {\n            color.setHex(500);\n        }\n        return color\n\n    }\n\n    resize = (width, height) => {\n        this.camera.aspect = width / height\n        this.camera.updateProjectionMatrix()\n        this.renderer.setSize(width, height)\n        this.composer.setSize(width, height);\n        \n    }\n\n    addLights= () =>{\n        this.createAmbientLight();\n        this.createPointLight();\n    }\n\n    createAmbientLight = () => {\n        this.ambientLight = new AmbientLight(0x999999, 1);\n        this.scene.add(this.ambientLight);\n    };\n    \n    createPointLight = () => {\n        this.light = new PointLight(0xffffff, 0.3, 0);\n        this.light.castShadow = true;\n        this.light.shadow.mapSize.width = 5000;\n        this.light.shadow.mapSize.height = 5000;\n        this.light.position.set(0,20,-5);\n        this.scene.add(this.light);\n\n        const light = new PointLight(0xffffff, 0.2, 0);\n        light.castShadow = false;\n        light.position.set(0,30,50);\n        this.scene.add(light);\n    };\n\n\n    animate = () => {\n\n\n        this.delta += 0.0025\n        // if (this.particleArr != null && this.array_of_dir != null && this.field_lines != null){\n        //     if(this.params.animatefield) this.animateField();\n        //     for(var i = 0; i < this.particleArr.length ; i++){\n        //         this.moveParticle(i)\n        //     }\n        // }\n\n        if(this.line){\n            this.updateVertices(this.line);\n        }\n        this.renderer.render( this.scene, this.camera )\n        //this.composer.render();\n        requestAnimationFrame( this.animate )\n        this.controls.update();\n    }\n\n    makeGeometry = () => {\n        var geometry = new PlaneBufferGeometry(this.width, this.height, 25,25)\n        this.line = new LineSegments(new WireframeGeometry(geometry), new LineBasicMaterial({color: 0xffffff}))\n        this.line.rotation.x = Math.PI/4\n        this.scene.add(this.line)\n\n    }\n\n    updateVertices(geom){\n\n        var vertices = geom.geometry.attributes.position.array;\n        //console.log(Math.random())\n        for(var i = 0; i<=vertices.length;i+=3){\n            vertices[i+2] = this.perlin.noise (vertices[i]/800 + this.delta, vertices[i+1]/800 + this.delta, 0.65) *300\n        }\n        geom.geometry.attributes.position.needsUpdate = true;\n    }\n\n    moveParticle = (i) => {\n\n        var x = Math.ceil((this.particleArr[i].p.x)/this.res)-1\n        var y = Math.ceil((this.particleArr[i].p.y)/this.res)-1\n        var value = this.array_of_dir[x][y]\n\n        this.particleArr[i].p.vx += Math.cos(value) * -0.01 \n        this.particleArr[i].p.vy += Math.sin(value) * 0.01\n\n        this.particleArr[i].p.x +=  this.particleArr[i].p.vx;\n        this.particleArr[i].p.y +=  this.particleArr[i].p.vy;\n\n        // apply some friction so point doesn't speed up too much\n        this.particleArr[i].p.vx *= 0.99;\n        this.particleArr[i].p.vy *= 0.99;\n\n        // wrap around edges of screen - boundaries\n        if(this.particleArr[i].p.x > this.width) this.particleArr[i].p.x = 1;\n        if(this.particleArr[i].p.y > this.height) this.particleArr[i].p.y = 1;\n        if(this.particleArr[i].p.x < 0) this.particleArr[i].p.x = this.width;\n        if(this.particleArr[i].p.y < 0) this.particleArr[i].p.y = this.height;\n\n        this.particleArr[i].sphere.position.set(this.particleArr[i].p.x - this.width/2, this.particleArr[i].p.y - this.height/2)\n\n    }\n    \n\n    makeScene = () => {\n\n        //field setup\n        this.res = 25 // resolution\n        this.width = 450 // flowfield width and height\n        this.height = 450\n        this.num_p = 25 // number of particles\n        \n        this.makeGeometry();\n\n        //make an array of particles with position and velocity\n    //     this.particleArr = new Array()\n\n    //     for (var i = 0; i < this.num_p; i++){\n\n    //         var p = {\n    //             x: Math.random() * this.width,\n    //             y: Math.random() * this.height,\n    //             vx: 0,\n    //             vy: 0\n    //         }\n\n    //         var color = this.getRandomColor()\n    //         var sphere  = new Mesh(new SphereGeometry(5, 5, 32), new MeshBasicMaterial( {color: color} ))\n    //         sphere.position.set(p.x, p.y)\n    //         this.scene.add(sphere);\n\n    //         var particle = {\n    //             p:p, sphere:sphere\n    //         }\n\n    //         this.particleArr[i] = particle\n            \n    //     }\n\n\n    //     //making array to store field values\n    //     this.array_of_boxes = new Array() // helper code to visualize field\n    //     this.array_of_dir = new Array() // array with all the vectors of the field\n\n    //     //with wireframed cones to visualize\n\n    //     //TO DO: data from perlin\n    //    // understanding the data\n    //    // get the debug working\n    //    // to the image\n\n    //     var value; // for field\n    //     for(var x = 0; x < this.width; x+=this.res ){\n    //         //console.log(x/res)\n    //         this.array_of_dir[x/this.res] = new Array();\n    //         this.array_of_boxes[x/this.res] = new Array();\n\n    //         for(var y = 0; y < this.height; y+=this.res){\n\n    //             value = this.perlin.noise( x * 0.65, y * 65, 0.65);\n\n    //             this.array_of_dir[x/this.res][y/this.res] = value * this.params.noise_value\n\n    //         }\n    //     }\n\n    //     this.makeField();\n    }\n\n    makeField = () => {\n\n        let angle = 0;\n        this.field_lines = new Group();\n       \n        for(var x = 0; x < this.width; x+=this.res ){\n\n            for(var y = 0; y < this.height; y+=this.res){\n                \n                angle = this.array_of_dir[x/this.res][y/this.res]\n                //console.log(\"show field \", angle)\n\n                const geometry = new ConeGeometry( 1, 25, 1 )\n                const cone = new Mesh( geometry, new MeshBasicMaterial( {color: 0xffffff, wireframe:true} )) //white color\n                cone.position.set(x-this.width/2+this.res/2, y-this.height/2+this.res/2, 10)\n                cone.rotateZ(angle)\n                this.field_lines.add(cone)\n\n            }\n        }\n        //field lines needs to be rotated horizontally to go from ' | ' to ' __ '\n        this.field_lines.rotateZ (Math.PI/2)\n\n        this.showField();\n\n    }\n\n    showField = () => {\n\n        if(this.params.showfield) this.scene.add(this.field_lines)\n        else this.scene.remove(this.field_lines)\n\n    }\n\n    animateField = () => {\n        let value;\n        let num=0;\n        for(var x = 0; x < this.width; x+=this.res ){\n            for(var y = 0; y < this.height; y+=this.res){\n\n                value = this.perlin.noise( x * 0.65, y * 65, this.delta);\n\n                this.array_of_dir[x/this.res][y/this.res] = value * this.params.noise_value\n                this.field_lines.children[num].rotateZ(value * this.params.noise_value)\n                num++\n            }\n        }\n        this.delta+= 0.00005\n    }\n    \n\n    createGUI = () => {\n\n        const gui = new GUI();\n        // gui\n        //     .add( this.afterimagePass.uniforms[ 'damp' ], 'value', 0, 1 )\n        //     .step( 0.001 )\n        //     .name('PostProcessing Damp')\n        // gui\n        //     .add(this.params, \"showfield\")\n        //     .onChange(this.showField)\n        //     .name('Show field')\n        // gui\n        //     .add(this.params, \"animatefield\")\n        //     .onChange(this.animateField)\n        //     .name('Animate field')\n        // gui\n        //     .add(this.params, \"noise_value\" , 'value', 0, 5)\n        //     .step( 0.1 )\n        //     .name('Noise value')\n    }\n}\n\nexport default WebGLApp;\n"]},"metadata":{},"sourceType":"module"}